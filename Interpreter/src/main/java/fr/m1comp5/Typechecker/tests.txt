public class TypeChecker implements MiniJajaVisitor {

    private String currentMethod = null; // Méthode courante
    private AppLogger logger = AppLogger.getInstance();
    private SymbolTable symbolTable = null;
    private Stack stack = null;

    public TypeChecker() {
        symbolTable = new SymbolTable(); // Initialiser la table des symboles globale
        stack = new Stack(); // Initialiser la pile
    }

    @Override
    public Object visit(ASTRoot node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTClasse node, Object data) {

        ASTIdent classNameNode = (ASTIdent) node.jjtGetChild(0);
        String className = (String) classNameNode.jjtGetValue();
        symbolTable.newScope();
        try {
            MemoryObject classMemoryObject = new MemoryObject(className, "Class" + className, ObjectNature.VAR,
                    ObjectType.OMEGA);
            symbolTable.putObjectInCurrentScope(classMemoryObject);
            stack.push(classMemoryObject);
        } catch (StackException | SymbolTableException e) {
            logger.logError("TypeChecker : Error adding class to symbol table: " + e.getMessage(), node.getLine(),
                    node.getColumn());
            e.printStackTrace();
        }

        // Visite des déclarations et méthodes dans la classe
        for (int i = 1; i < node.jjtGetNumChildren(); i++) {
            node.jjtGetChild(i).jjtAccept(this, data);
        }

        try {
            MemoryObject mo = symbolTable.get(className);
            stack.eraseVariable(className);
            symbolTable.removeObjectFromCurrentScope(mo);
            symbolTable.popScope(); // Retirer la portée de la classe après traitement
        } catch (SymbolTableException | StackException e) {
            e.printStackTrace();
        }
        return null;

    }

    @Override
    public Object visit(ASTIdent node, Object data) {
        Object value = node.jjtGetValue();

        if (value instanceof String) {
            String ident = (String) value;
            if (ident.matches("[a-zA-Z][a-zA-Z0-9]*")) {
                return ident;
            } else {

                logger.logError("TypeChecker  : Invalid identifier: " + ident
                        + ". Identifiers must start with a letter and contain only letters and digits.", node.getLine(),node.getColumn());
            }
        } else {
            logger.logError("TypeChecker  : Expected a string identifier, but got: " + value, node.getLine(),
                    node.getColumn());
        }
        return null;
    }

    @Override
    public Object visit(ASTVnil node, Object data) {
        return ObjectType.OMEGA;
    }

    @Override
    public Object visit(ASTDecls node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTCst node, Object data) {
        Object cstType = node.jjtGetChild(0).jjtAccept(this, data);
        if (!(cstType instanceof ObjectType)) {
            logger.logError("Expected ObjectType but got " + cstType.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }
        ObjectType cstTypeObject = (ObjectType) cstType;
        String cstName = (String) ((ASTIdent) node.jjtGetChild(1)).jjtGetValue();
        Object cstValue = null;
        if (node.jjtGetNumChildren() > 2) {
            cstValue = node.jjtGetChild(2).jjtAccept(this, data); 
        }
        /* if (isDefined(cstName, cstTypeObject, ObjectNature.CST)) {
            logger.logError("TypeChecker  : Constant " + cstName + " is already defined.", node.getLine(),
                    node.getColumn());

        } */
        MemoryObject mo;
        try {
            if (cstValue == null || cstValue == ObjectType.OMEGA)
                mo = new MemoryObject(cstName, null, ObjectNature.VCST, cstTypeObject);
            else
                mo = new MemoryObject(cstName, cstValue, ObjectNature.CST, cstTypeObject);
            symbolTable.putObjectInCurrentScope(mo);
            stack.push(mo);
        } catch (SymbolTableException | StackException e) {
            e.printStackTrace();
        }

        return cstTypeObject;

    }

    @Override
    public Object visit(ASTVars node, Object data) {
        return visitChildren(node, data);
    }

        @Override
    public Object visit(ASTVar node, Object data) {
        ASTIdent identNode = (ASTIdent) node.jjtGetChild(1);
        String varName = identNode.jjtGetValue().toString();
    
        Object varType = node.jjtGetChild(0).jjtAccept(this, data);
        if (!(varType instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + varType.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }
        ObjectType varTypev = (ObjectType) varType;
    
        // Vérifiez si une expression d'initialisation est présente
        if (node.jjtGetNumChildren() > 2) {
            ObjectType typeExp = getNodeType(node.jjtGetChild(2), data);
            if (typeExp == null || typeExp == ObjectType.OMEGA) {
                MemoryObject mo = new MemoryObject(varName, null, ObjectNature.VAR, varTypev);
                try {
                    symbolTable.putObjectInCurrentScope(mo);
                    stack.push(mo);
                } catch (SymbolTableException | StackException e) {
                    e.printStackTrace();
                }
                return varTypev;
            }
            if (!(typeExp instanceof ObjectType)) {
                logger.logError("TypeChecker  : Expected ObjectType but got " + typeExp.getClass().getSimpleName(),
                        node.getLine(), node.getColumn());
                return null;
            }
    
            if (typeExp != varType) {
                logger.logError(
                        "TypeChecker  : Type mismatch Cannot assign " + typeExp + " to " + identNode + " of type "
                                + varType,
                        node.getLine(), node.getColumn());
            }
    
            MemoryObject mo = new MemoryObject(varName, null, ObjectNature.VAR, varTypev);
            try {
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
        } else {
            // Déclarez simplement la variable sans initialisation
            MemoryObject mo = new MemoryObject(varName, null, ObjectNature.VAR, varTypev);
            try {
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
        }
    
        visitChildren(node, data);
        return varTypev;
    }

    /* @Override
    public Object visit(ASTVar node, Object data) {
        ASTIdent identNode = (ASTIdent) node.jjtGetChild(1);
        String varName = identNode.jjtGetValue().toString();

        Object varType = (Object) node.jjtGetChild(0).jjtAccept(this, data);
        if (!(varType instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + varType.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }
        ObjectType varTypev = (ObjectType) varType;

        ObjectType typeExp = getNodeType(node.jjtGetChild(2), data);
        if (typeExp == null || typeExp == ObjectType.OMEGA) {
            MemoryObject mo = new MemoryObject(varName, null, ObjectNature.VAR, varTypev);
            try {
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
            return varTypev;
        }
        if (!(typeExp instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + typeExp.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }

        if (typeExp != varType) {
            logger.logError(
                    "TypeChecker  : Type mismatch Cannot assign " + typeExp + " to " + identNode + " of type "
                            + varType,
                    node.getLine(), node.getColumn());
        }
       /*  if (isDefined(varName, typeExp, ObjectNature.VAR)) {
            MemoryObject mp = lookupSymbol(varName);
            if (mp != null && mp.getType() == varType) {
                logger.logError(
                        "TypeChecker  : Variable " + varName + " is already defined with the same type " + varType,
                        node.getLine(), node.getColumn());
            }
        } else { 
            MemoryObject mo = new MemoryObject(varName, null, ObjectNature.VAR, varTypev);
            try {
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
        //}
        visitChildren(node, data);
        return varTypev;
    } */

    @Override
    public Object visit(ASTTableau node, Object data) {
        String arrayName = (String) node.jjtGetChild(1).jjtAccept(this, data); // nom
        // vérifier le type du tableau
        Object arrayTypep = node.jjtGetChild(0).jjtAccept(this, data);
        if (!(arrayTypep instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + arrayTypep.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }
        ObjectType arrayType = (ObjectType) arrayTypep;
        // verifie type de l'index
        ObjectType IndextypeExp = getNodeType(node.jjtGetChild(2), data);
        if (IndextypeExp == null) {
            logger.logError("TypeChecker  : Index type cannot be null.", node.getLine(), node.getColumn());
            return null;
        } else if (IndextypeExp != ObjectType.INT) {
            logger.logError("TypeChecker  : Index must be of type int.", node.getLine(), node.getColumn());
            return null;
        }

        /* if (isDefined(arrayName, arrayType, ObjectNature.TAB)) {
            logger.logError("TypeChecker  : Tableau " + arrayName + " is already defined.", node.getLine(),
                    node.getColumn());
        } else */ 
            MemoryObject mo = new MemoryObject(arrayName, null, ObjectNature.TAB, arrayType);
            try {
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
        
        return arrayType;
    }

    @Override
    public Object visit(ASTOmega node, Object data) {
        return ObjectType.OMEGA;
    }

    @Override
    public Object visit(ASTMethode node, Object data) {

        Object returnTypeObject = node.jjtGetChild(0).jjtAccept(this, data);
        if (!(returnTypeObject instanceof ObjectType)) {
            logger.logError(
                    "TypeChecker  : Expected type valide but found " + returnTypeObject.getClass().getSimpleName(),
                    node.getLine(), node.getColumn());
            return null;
        }
        ObjectType returnType = (ObjectType) returnTypeObject;
        String methodName = (String) node.jjtGetChild(1).jjtAccept(this, data);
        List<ObjectType> paramTypes = new ArrayList<>();
        List<String> paramNames = new ArrayList<>();

        // Récupérer les types des paramètres
        if (node.jjtGetChild(2) instanceof ASTEntetes) {
            ASTEntetes entetesNode = (ASTEntetes) node.jjtGetChild(2);
            collectParamTypesAndNames(entetesNode, paramTypes, paramNames, data);
        }

        // Construire la signature de la méthode
        StringBuilder signatureBuilder = new StringBuilder(methodName);
        signatureBuilder.append("(");
        for (ObjectType paramType : paramTypes) {
            signatureBuilder.append(paramType.toString()).append(",");
        }
        if (!paramTypes.isEmpty()) {
            signatureBuilder.setLength(signatureBuilder.length() - 1);
        }
        signatureBuilder.append(")");
        String methodSignature = signatureBuilder.toString();

        // Vérifier si la méthode avec cette signature est déjà définie
        if (isDefined(methodName, returnType, ObjectNature.METH)) {
            logger.logError("TypeChecker  : Method " + methodSignature + " is already defined.", node.getLine(),
                    node.getColumn());

        } else {
            try {
                MemoryObject mo = new MemoryObject(methodSignature, null, ObjectNature.METH, returnType, paramTypes);
                symbolTable.putObjectInCurrentScope(mo);
                stack.push(mo);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
            currentMethod = methodSignature;
        }

        // Ajouter les paramètres dans la table des symboles
        for (int i = 0; i < paramNames.size(); i++) {
            String paramName = paramNames.get(i);
            ObjectType paramType = paramTypes.get(i);
            MemoryObject paramObject = new MemoryObject(paramName, null, ObjectNature.VAR, paramType);
            try {
                // symbolTable.newScope();
                symbolTable.putObjectInCurrentScope(paramObject);
                stack.push(paramObject);
            } catch (SymbolTableException | StackException e) {
                e.printStackTrace();
            }
        }
        node.jjtGetChild(3).jjtAccept(this, data); // vars
        node.jjtGetChild(4).jjtAccept(this, data); // instrs

        // réinitialiser
        try {
            MemoryObject mo = symbolTable.get(methodName);
            stack.eraseVariable(methodName);
            symbolTable.removeObjectFromCurrentScope(mo);
        } catch (StackException | SymbolTableException e) {
            e.printStackTrace();
        }
        currentMethod = null;
        return null;
    }

    private void collectParamTypesAndNames(ASTEntetes entetesNode, List<ObjectType> paramTypes, List<String> paramNames,
            Object data) {
        for (int i = 0; i < entetesNode.jjtGetNumChildren(); i++) {
            SimpleNode child = (SimpleNode) entetesNode.jjtGetChild(i);
            if (child instanceof ASTEntete) {
                ObjectType paramType = (ObjectType) child.jjtGetChild(0).jjtAccept(this, data);
                String paramName = (String) child.jjtGetChild(1).jjtAccept(this, data);
                if (paramType == null) {
                    logger.logInfo("Parameter type cannot be null.");
                } else {
                    paramTypes.add(paramType);
                    paramNames.add(paramName);
                }
            } else if (child instanceof ASTEntetes) {
                collectParamTypesAndNames((ASTEntetes) child, paramTypes, paramNames, data);
            }
        }
    }

    @Override
    public Object visit(ASTMain node, Object data) {

        symbolTable.newScope();
        currentMethod = "Methmain";
        visitChildren(node, data);
        try {
            symbolTable.popScope();
        } catch (Exception e) {
            logger.logError("TypeChecker : Error popping main method scope: " + e.getMessage(), node.getLine(),
                    node.getColumn());
            e.printStackTrace();
        }
        
        currentMethod = null;

        return null;
    }

    @Override
    public Object visit(ASTEnil node, Object data) {
        return ObjectType.OMEGA;
    }

    @Override
    public Object visit(ASTEntetes node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTEntete node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTInil node, Object data) {
        return ObjectType.OMEGA;
    }

    @Override
    public Object visit(ASTInstrs node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTRetour node, Object data) {
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTEcrire node, Object data) {
        return node.jjtGetChild(0).jjtAccept(this, data);
    }

    @Override
    public Object visit(ASTEcrireLn node, Object data) {
        return node.jjtGetChild(0).jjtAccept(this, data);
    }

    @Override
    public Object visit(ASTSi node, Object data) {
        ObjectType conditionType = (ObjectType) node.jjtGetChild(0).jjtAccept(this, data);
        if (conditionType != ObjectType.BOOLEAN) {
            logger.logError("TypeChecker  : Condition in if statement must be boolean.", node.getLine(),
                    node.getColumn());
        }
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTTantQue node, Object data) {
        ObjectType conditionType = (ObjectType) node.jjtGetChild(0).jjtAccept(this, data);
        if (conditionType != ObjectType.BOOLEAN) {
            logger.logError("TypeChecker  : Condition in while statement must be boolean.", node.getLine(),
                    node.getColumn());
        }
        return visitChildren(node, data);
    }

    @Override
    public Object visit(ASTAffectation node, Object data) {
        ObjectType id = getNodeType(node.jjtGetChild(0), data);
        ObjectType id2 = getNodeType(node.jjtGetChild(1), data);
        if (id == null) {
            return null;
        }
        if (id2 == null) {
            return null;
        }
        if (id != id2) {
            logger.logError("TypeChecker  : Type mismatch Cannot assign " + id2 + " to " + id, node.getLine(),
                    node.getColumn());
        }

        return id;
    }

    @Override
    public Object visit(ASTIncrement node, Object data) {
        String varName = (String) node.jjtGetChild(0).jjtAccept(this, data); // nom de la variable
        MemoryObject mo = lookupSymbol(varName);

        if (mo == null) {
            logger.logError("TypeChecker  : Variable " + varName + " is not defined.", node.getLine(),
                    node.getColumn());
        }
        if (mo.getType() != ObjectType.INT) {
            logger.logError("TypeChecker : Type mismatch Cannot increment non-integer variable.", node.getLine(),
                    node.getColumn());
        }
        return ObjectType.INT;
    }

    private Object visitMethodCall(SimpleNode node, Object data) {
        String methodName = (String) node.jjtGetChild(0).jjtAccept(this, data);
        List<ObjectType> actualParamTypes = new ArrayList<>();

        // Construire la signature de la méthode à partir des paramètres
        Object paramsData = node.jjtGetChild(1);
        if (paramsData instanceof ASTListExp) {
            ASTListExp paramsNode = (ASTListExp) paramsData;
            collectParamTypesFromListexp(paramsNode, actualParamTypes, data);
        }

        // Construire la signature complète de la méthode
        StringBuilder signatureBuilder = new StringBuilder(methodName);
        signatureBuilder.append("(");
        for (ObjectType paramType : actualParamTypes) {
            signatureBuilder.append(paramType.toString()).append(",");
        }
        if (!actualParamTypes.isEmpty()) {
            signatureBuilder.setLength(signatureBuilder.length() - 1); // Supprimer la dernière virgule
        }
        signatureBuilder.append(")");
        String methodSignature = signatureBuilder.toString();

        // Rechercher la méthode avec la signature complète
        MemoryObject mo = lookupSymbol(methodSignature);

        if (node instanceof ASTAppelI) {
            ASTAppelI appelI = (ASTAppelI) node;
            if (mo == null) {
                logger.logError("TypeChecker  : Method " + methodSignature + " is not defined.", appelI.getLine(),
                        appelI.getColumn());
                return null;
            }
        } else if (node instanceof ASTAppelE) {
            ASTAppelE appelE = (ASTAppelE) node;
            if (mo == null) {
                logger.logError("TypeChecker  : Method " + methodSignature + " is not defined.", appelE.getLine(),
                        appelE.getColumn());
                return null;
            }
        }

        // Vérifier les types des paramètres
        List<ObjectType> expectedParamTypes = mo.getParamTypes();
        if (expectedParamTypes.size() != actualParamTypes.size()) {
            if (node instanceof ASTAppelI) {
                ASTAppelI appelI = (ASTAppelI) node;
                logger.logError("TypeChecker :  Parameter count mismatch in method " + methodSignature,
                        appelI.getLine(),
                        appelI.getColumn());
                return null;
            } else if (node instanceof ASTAppelE) {
                ASTAppelE appelE = (ASTAppelE) node;
                logger.logError("TypeChecker : Parameter count mismatch in method " + methodSignature, appelE.getLine(),
                        appelE.getColumn());
                return null;
            }
        }

        for (int i = 0; i < expectedParamTypes.size(); i++) {
            if (expectedParamTypes.get(i) != actualParamTypes.get(i)) {
                if (node instanceof ASTAppelI) {
                    ASTAppelI appelI = (ASTAppelI) node;
                    logger.logError(
                            "TypeChecker : Parameter type mismatch in method " + methodSignature + ": expected "
                                    + expectedParamTypes.get(i) + " but got " + actualParamTypes.get(i),
                            appelI.getLine(), appelI.getColumn());
                    return null;
                } else if (node instanceof ASTAppelE) {
                    ASTAppelE appelE = (ASTAppelE) node;
                    logger.logError(
                            "TypeChecker : Parameter type mismatch in method " + methodSignature + ": expected "
                                    + expectedParamTypes.get(i) + " but got " + actualParamTypes.get(i),
                            appelE.getLine(), appelE.getColumn());
                    return null;
                }
            }
        }

        return mo.getType();
    }

    @Override
    public Object visit(ASTAppelI node, Object data) {
        return visitMethodCall(node, data);
    }

    @Override
    public Object visit(ASTAppelE node, Object data) {
        return visitMethodCall(node, data);
    }

    @Override
    public Object visit(ASTListExp node, Object data) {

        if (node.jjtGetNumChildren() == 2) {
            SimpleNode firstChild = (SimpleNode) node.jjtGetChild(0);
            SimpleNode secondChild = (SimpleNode) node.jjtGetChild(1);
            if (firstChild instanceof ASTExp) {
                Object paramType = firstChild.jjtAccept(this, data);
                // ObjectType paramType = (ObjectType) firstChild.jjtAccept(this, data);
                if (paramType == null) {
                    logger.logError("TypeChecker : Parameter type cannot be null.", node.getLine(), node.getColumn());
                }
            } else {
                logger.logError(
                        "TypeChecker : Unexpected node type in ASTListExp: " + firstChild.getClass().getSimpleName(),
                        node.getLine(), node.getColumn());
            }
            if (secondChild instanceof ASTListExp) {
                return secondChild.jjtAccept(this, data);
            } else if (!(secondChild instanceof ASTExnil)) {
                logger.logError(
                        "TypeChecker : Unexpected node type in ASTListExp: " + firstChild.getClass().getSimpleName(),
                        node.getLine(), node.getColumn());
            }
        } else if (node.jjtGetNumChildren() == 1) {
            if (node.jjtGetChild(0) instanceof ASTExnil) {
                return ObjectType.OMEGA;
            }
        }
        return null;
    }

    @Override
    public Object visit(ASTExp node, Object data) {
        
         Object result = null;
          for (int i = 0; i < node.jjtGetNumChildren(); i++) {
          result = node.jjtGetChild(i).jjtAccept(this, data);
          }
          return result;
         
    }

    private void collectParamTypesFromListexp(ASTListExp listexpNode, List<ObjectType> paramTypes, Object data) {
        if (listexpNode.jjtGetNumChildren() == 2) {
            SimpleNode firstChild = (SimpleNode) listexpNode.jjtGetChild(0);
            SimpleNode secondChild = (SimpleNode) listexpNode.jjtGetChild(1);

            if (firstChild instanceof ASTExp) {
                ObjectType paramType = (ObjectType) firstChild.jjtAccept(this, data);
                if (paramType == null) {
                    logger.logInfo("Parameter type cannot be null.");
                } else {
                    paramTypes.add(paramType);
                }
            }

            if (secondChild instanceof ASTListExp) {
                collectParamTypesFromListexp((ASTListExp) secondChild, paramTypes, data);
            } else if (!(secondChild instanceof ASTExnil)) {
                logger.logInfo("Unexpected node type in ASTListExp: " + secondChild.getClass().getSimpleName());
            }
        } else if (listexpNode.jjtGetNumChildren() == 1) {
            if (listexpNode.jjtGetChild(0) instanceof ASTExnil) {
                return;
            }

        }
    }

    @Override
    public Object visit(ASTExnil node, Object data) {
        return ObjectType.OMEGA;
    }

    @Override
    public Object visit(ASTNot node, Object data) {
        return visitUnaryOperation(node, data, ObjectType.BOOLEAN);
    }

    @Override
    public Object visit(ASTNeg node, Object data) {
        return visitUnaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTEt node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.BOOLEAN);
    }

    @Override
    public Object visit(ASTOu node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.BOOLEAN);
    }

    @Override
    public Object visit(ASTEq node, Object data) {

        ObjectType leftType = getNodeType(node.jjtGetChild(0), data);
        ObjectType rightType = getNodeType(node.jjtGetChild(1), data);

        if (leftType != rightType) {
            logger.logError(
                    "TypeChecker : Type mismatch Expected same type (Boolean) for both operands for equivalence expression.",
                    node.getLine(), node.getColumn());
        }
        return ObjectType.BOOLEAN;
    }

    @Override
    public Object visit(ASTSup node, Object data) {

        ObjectType leftType = getNodeType(node.jjtGetChild(0), data);
        ObjectType rightType = getNodeType(node.jjtGetChild(1), data);

        if (leftType != rightType && leftType != ObjectType.INT && rightType != ObjectType.INT) {
            logger.logError("TypeChecker : Type mismatch Expected type Boolean for both operands.", node.getLine(),
                    node.getColumn());
        }
        return ObjectType.BOOLEAN;
    }

    @Override
    public Object visit(ASTAdd node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTSub node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTMul node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTSomme node, Object data) {
        return visitBinaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTDiv node, Object data) {

        Object value = node.jjtGetChild(1).jjtAccept(this, data);

        if (value instanceof Integer) {
            int rightValue = (Integer) value;
            if (rightValue == 0) {
                logger.logError("TypeChecker  :  not allowed to divide by zero!", node.getLine(), node.getColumn());
            }
        } 
        if (value instanceof ASTVar || value instanceof ASTTab || value instanceof ASTAppelE || value instanceof ASTCst) {
            ObjectType rightType = getNodeType(node.jjtGetChild(1), data);
            if (rightType != ObjectType.INT) {
                logger.logError("TypeChecker  : Expected type int for division operation.", node.getLine(),
                        node.getColumn());
            }
        }
        return visitBinaryOperation(node, data, ObjectType.INT);
    }

    @Override
    public Object visit(ASTLongeur node, Object data) {

        ASTIdent identNode = (ASTIdent) node.jjtGetChild(0);
        Object value = identNode.jjtGetValue();
        if (value instanceof String) {
            return ObjectType.INT;
        } else {
            logger.logError("TypeChecker  : Expected a string identifier, but got: " + value, node.getLine(),
                    node.getColumn());
        }

        return null;
    }

    @Override
    public Object visit(ASTVrai node, Object data) {
        return ObjectType.BOOLEAN;
    }

    @Override
    public Object visit(ASTFaux node, Object data) {
        return ObjectType.BOOLEAN;
    }

    @Override
    public Object visit(ASTTab node, Object data) {
        String id = (String) ((ASTIdent) node.jjtGetChild(0)).jjtGetValue();
        Object indx = getNodeType(node.jjtGetChild(1), data);

        MemoryObject mo = lookupSymbol(id);
        if (mo == null) {
            logger.logError("TypeChecker  : Tableau " + id + " is not defined.", node.getLine(), node.getColumn());
            return null;
        }
        if (mo.getType() != ObjectType.INT) {
            logger.logError("TypeChecker  : Tableau " + id + " must be of type int.", node.getLine(), node.getColumn());
            return null;
        }
        if (indx != ObjectType.INT) {
            logger.logError("TypeChecker  : Index must be of type int.", node.getLine(), node.getColumn());
            return null;
        }
        return ObjectType.INT;
    }

    @Override
    public Object visit(ASTRien node, Object data) {
        return ObjectType.VOID;
    }

    @Override
    public Object visit(ASTEntier node, Object data) {
        return ObjectType.INT;
    }

    @Override
    public Object visit(ASTBooleen node, Object data) {
        return ObjectType.BOOLEAN;
    }

    @Override
    public Object visit(ASTNbre node, Object data) {

        Object value = node.jjtGetValue();
        if (value instanceof Integer) {
            return ObjectType.INT;
        } else {
            logger.logError("TypeChecker  : Expected an integer value, but got: " + value, node.getLine(),
                    node.getColumn());
        }
        return null;
    }

    @Override
    public Object visit(ASTChaine node, Object data) {
        Object value = node.jjtGetValue();
        if (value instanceof String) {
            String chaine = (String) value;
            return chaine;
        } else {
            logger.logError("TypeChecker  : Expected a string chaine, but got: " + value, node.getLine(),
                    node.getColumn());
        }

        return null;
    }

    /*
     * private ObjectType visitBinaryOperation(SimpleNode node, Object data,
     * ObjectType expectedType) {
     * Object leftTypep = node.jjtGetChild(0).jjtAccept(this, data);
     * Object rightTypep = node.jjtGetChild(1).jjtAccept(this, data);
     * if (!(leftTypep instanceof ObjectType) || !(rightTypep instanceof
     * ObjectType)) {
     * logger.logError("TypeChecker  : Expected ObjectType but got " +
     * leftTypep.getClass().getSimpleName());
     * return null;
     * }
     * 
     * 
     * ObjectType leftType = (ObjectType) leftTypep;
     * ObjectType rightType = (ObjectType) rightTypep;
     * 
     * if (leftType != expectedType || rightType != expectedType) {
     * logger.logError("TypeChecker  : Type mismatch Expected " + expectedType +
     * " for operand.");
     * }
     * return expectedType;
     * 
     * }
     */
    private ObjectType visitBinaryOperation(SimpleNode node, Object data, ObjectType expectedType) {
        if (node.jjtGetNumChildren() != 2 || node.jjtGetChild(0) == null || node.jjtGetChild(1) == null) {
            logger.logError("TypeChecker  : Binary operation must have two operands.", 0,
                    0);
            return null;
        }
        Object leftTypep = getNodeType(node.jjtGetChild(0), data);
        Object rightTypep = getNodeType(node.jjtGetChild(1), data);

        if (!(leftTypep instanceof ObjectType) || !(rightTypep instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + rightTypep,0,0);
            return null;
        }

        ObjectType leftType = (ObjectType) leftTypep;
        ObjectType rightType = (ObjectType) rightTypep;

        if (leftType != expectedType || rightType != expectedType) {
            logger.logError("TypeChecker  : Type mismatch Expected " + expectedType + " for operand.",0,0);
        }
        return expectedType;
    }

    private ObjectType getNodeType(Node node, Object data) {
        if (node instanceof ASTIdent) {
            Object value = node.jjtAccept(this, data);
            if (value instanceof String) {
                String varName = (String) value;
                MemoryObject memoryObject = lookupSymbol(varName);
                if (memoryObject != null) {
                    return memoryObject.getType();
                } else {
                    logger.logInfo("variable " + varName + " is not defined.");
                }
            } else {
                logger.logError("TypeChecker : Expected a string identifier, but got: " + value,0,0);
            }
        } else if (node instanceof ASTVar || node instanceof ASTCst || node instanceof ASTTableau
                || node instanceof ASTTab) {
            Object value = node.jjtAccept(this, data);
            if (value instanceof String) {
                String varName = (String) value;
                MemoryObject memoryObject = lookupSymbol(varName);
                if (memoryObject != null) {
                    return memoryObject.getType();
                }
            } else {
                logger.logError("TypeChecker : Expected a string identifier, but got: " + value,0,0);
            }
        } else if (node instanceof ASTAppelE) {
            return (ObjectType) visitMethodCall((SimpleNode) node, data);
        } else if (node instanceof ASTNbre) {
            return ObjectType.INT;
        } else if (node instanceof ASTVrai || node instanceof ASTFaux) {
            return ObjectType.BOOLEAN;
        } else {
            Object result = node.jjtAccept(this, data);
            if (result instanceof ObjectType) {
                return (ObjectType) result;
            } else {
                logger.logError("TypeChecker : Expected ObjectType but got " + result,0,0);
            }
        }
        return null;
    }

    /*
     * private ObjectType getNodeType(Node node, Object data) {
     * if (node instanceof ASTIdent) {
     * String varName = (String) node.jjtAccept(this, data);
     * MemoryObject memoryObject = lookupSymbol(varName);
     * if (memoryObject != null) {
     * return memoryObject.getType();
     * } else {
     * logger.logInfo("variable " + varName + " is not defined.");
     * }
     * } else if (node instanceof ASTVar || node instanceof ASTCst || node
     * instanceof ASTTableau || node instanceof ASTTab) {
     * String varName = (String) node.jjtAccept(this, data);
     * MemoryObject memoryObject = lookupSymbol(varName);
     * if (memoryObject != null) {
     * return memoryObject.getType();
     * }
     * } else if (node instanceof ASTAppelE) {
     * return (ObjectType) visitMethodCall((SimpleNode) node, data);
     * } else if (node instanceof ASTNbre) {
     * return ObjectType.INT;
     * } else if (node instanceof ASTVrai || node instanceof ASTFaux) {
     * return ObjectType.BOOLEAN;
     * }else {
     * Object result = node.jjtAccept(this, data);
     * if (result instanceof ObjectType) {
     * return (ObjectType) result;
     * } else {
     * logger.logError("TypeChecker : Expected ObjectType but got " + result);
     * }
     * }
     * return null;
     * }
     */
    /*
     * private ObjectType getNodeType(Node node, Object data) {
     * if (node instanceof ASTIdent || node instanceof ASTVar || node instanceof
     * ASTCst
     * || node instanceof ASTTableau) {
     * String varName = (String) node.jjtAccept(this, data);
     * MemoryObject memoryObject = lookupSymbol(varName);
     * if (memoryObject != null) {
     * return memoryObject.getType();
     * } else {
     * logger.logInfo("variable " + varName + " is not defined.");
     * }
     * } else if (node instanceof ASTNbre) {
     * return ObjectType.INT;
     * } else if (node instanceof ASTTab) {
     * String varName = (String) node.jjtGetChild(0).jjtAccept(this, data);
     * MemoryObject memoryObject = lookupSymbol(varName);
     * if (memoryObject != null) {
     * return memoryObject.getType();
     * }
     * } else if (node instanceof ASTVrai || node instanceof ASTFaux) {
     * return ObjectType.BOOLEAN;
     * } else {
     * return (ObjectType) node.jjtAccept(this, data);
     * }
     * return null;
     * }
     */
    private ObjectType visitUnaryOperation(SimpleNode node, Object data, ObjectType expectedType) {
        Object operandTypep = node.jjtGetChild(0).jjtAccept(this, data);
        if (!(operandTypep instanceof ObjectType)) {
            logger.logError("TypeChecker  : Expected ObjectType but got " + operandTypep.getClass().getSimpleName(),0,0);
            return null;
        }
        ObjectType operandType = (ObjectType) operandTypep;
        if (operandType != expectedType) {
            logger.logError("TypeChecker  : Type mismatch Expected " + expectedType + " for operand.",0,0);
        }
        return expectedType;
    }

    private Object visitChildren(SimpleNode node, Object data) {
        for (int i = 0; i < node.jjtGetNumChildren(); i++) {
            node.jjtGetChild(i).jjtAccept(this, data);
        }
        return null;
    }

    public MemoryObject lookupSymbol(String name) {
        try {
            if (stack.empty()) {
                throw new StackException("The stack is empty, cannot lookup symbol");
            }
            // SymbolTable symbolTable = (SymbolTable) stack.getTop().getValue();
            MemoryObject mo = stack.searchVariableFromTop(name);
            if (mo != null) {
                return mo;
            }
            // return symbolTable.get(name);
        } catch (StackException e) {
            System.err.println("Error: " + e.getMessage());
            return null;
        }
        return null;
    }

    public Boolean isDefined(String name, ObjectType type, ObjectNature nat) {
        MemoryObject mo = lookupSymbol(name);
        if (mo != null) {
            return type == mo.getType() && nat == mo.getNature();
        }
        return false;
    }

    /*
     * public List<MemoryObject> lookupMethode() {
     * List<MemoryObject> methods = new ArrayList<>();
     * try {
     * if (symbolTable == null) {
     * throw new StackException("The stack is empty, cannot lookup symbol");
     * }
     * for (List<MemoryObject> bucket : symbolTable.getBuckets()) {
     * if (bucket != null) {
     * for (MemoryObject mo : bucket) {
     * if (mo.getNature() == ObjectNature.METH || mo.getNature() == ObjectNature.VAR
     * || mo.getNature() == ObjectNature.TAB) {
     * methods.add(mo);
     * }
     * }
     * }
     * }
     * } catch (StackException e) {
     * System.err.println("Error: " + e.getMessage());
     * }
     * return methods;
     * }
     */
/* 
    @Override
    public Object visit(SimpleNode node, Object data) {
        visitChildren(node, null);
        return node.jjtAccept(this, data);
    }
} */ */
