options {
    STATIC = false;
}

PARSER_BEGIN(MiniJajaParser)
package fr.m1comp5.LexerParserGenerator.MiniJajaParser;
import java.io.FileReader;

public class MiniJajaParser
{
    public static MiniJajaParser getInstance(String filename)
    {
        FileReader reader = null;
        try
        {
            reader = new FileReader(filename);
        }
        catch (Exception e)
        {
            System.out.println(e.getMessage());
            return null;
        }
        return new MiniJajaParser(reader);
    }
}
PARSER_END(MiniJajaParser)


/* MiniJaja reserved keywords */
<DEFAULT> TOKEN :
{
    <CLASS: "class">     |
    <MAIN: "main">       |
    <VOID: "void">       |
    <INT: "int">         |
    <BOOLEAN: "boolean"> |
    <FINAL: "final">     |
    <TRUE: "true">       |
    <FALSE: "false">     |
    <LENGTH: "length">   |
    <WHILE: "while">     |
    <RETURN: "return">   |
    <WRITE: "write">     |
    <WRITELN: "writeln"> |
    <IF : "if">          |
    <ELSE : "else">
}

<DEFAULT> TOKEN : {
    <IDENTIFIER: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])*> |
    <ASSIGN_OPERATOR: "="> |
    <ADD_OPERATOR: "+"> |
    <SUB_OPERATOR: "-"> |
    <DIV_OPERATOR: "/"> |
    <MULTIPLY_OPERATOR: "*"> |
    <NUMBER: (["0"-"9"])+>   |
    <SEPARATOR: ";">         |
    <SUP : ">">              |
    <INF : "<" >             |
    <AND_LOGIC : "&&">       | 
    <OR_LOGIC  : "||">       |
    <NEGATION  : "!">        |
    <VIRGULE  : ",">   
}


void classe() : {}
{
    <CLASS> ident() "{" decls() methmain() "}"
}

void ident() : {}
{
    <IDENTIFIER>
}

void decls() : {}
{
    decl() <SEPARATOR> decls() | empty()
}

void decl() : {}
{
    typemeth() ident() decl2()    |
    <FINAL> type() ident() vexp() |
    empty()
}

void decl2() : {}
{
    var2() | "(" entetes() ")" "{" vars() instrs() "}"
}

void vars() : {}
{
    var() <SEPARATOR> vars() | empty()

}

void var() : {}
{
    typemeth() ident() var2() |  <FINAL>  type() ident() vexp()
}

void var2() : {}
{
    vexp() | "[" exp() "]"
}

void vexp() : {}
{
    <ASSIGN_OPERATOR> exp() | empty()
}

void exp() : {}
{
    <NEGATION> exp1() exp5() | exp1() exp5()
}

void exp5() : {}
{
    <AND_LOGIC> exp1() exp52() |
    <OR_LOGIC>exp1() exp52()   |
    empty()
}

void exp52() : {}
{
    <AND_LOGIC> exp1() exp52() |
    <OR_LOGIC> exp1() exp52()  |
    empty()
}

void exp1() : {}
{
    exp2() exp42()
}

void exp42() : {}
{
    <ASSIGN_OPERATOR><ASSIGN_OPERATOR> exp2() exp42() |
    <SUP> exp2() exp42()                              |
    empty()
}

void exp2() : {}
{
    terme() exp32()
}

void exp32() : {}
{
    <ADD_OPERATOR> terme() exp32() |
    <SUB_OPERATOR> terme() exp32() |
    empty()
}

void terme() : {}
{
    fact() terme22()
}

void terme22() : {}
{
    <MULTIPLY_OPERATOR> fact() terme22() |
    <DIV_OPERATOR> fact() terme22()      |
    empty()
}

void fact() : {}
{   
    ident() fact2()|
    <LENGTH> "(" ident() ")" |
    "(" exp() ")" |
    <NUMBER>      |
    <TRUE>        |
    <FALSE>
}

void fact2() : {}
{
    "(" listexp() ")" | empty()
}

void ident1() : {}
{
    ident()
}

void ident2() : {}
{
    ident() "[" exp() "]"
}

void typemeth() : {}
{
    <VOID> | type()

}

void type() : {}
{
    <INT> | <BOOLEAN>

}

/**
* Empty production rule
*/
void empty() : {}
{
    {}
}

void methode() : {} 
{
    typemeth() ident() "(" entetes() ")" vars() instrs() | empty()

}
void methmain() : {}
{
    <MAIN> "{" vars() instrs() "}"
}

void entetes() : {}
{
    entete() entetes2() | empty()
}

void entetes2() : {}
{
    <VIRGULE> entetes() | empty()
}

void entete() : {}
{
    type() ident()
}

void instrs() : {}
{
 instr() <SEPARATOR> instrs() | empty()
}
void instr() : {}
{
    ident() instr2() |
    <RETURN> exp() |
    <WRITE> "(" I() ")" |
    <WRITELN> "(" I() ")" |
    <IF> "(" exp() ")" "{" instrs() "}" ELSE() |
    <WHILE> "(" exp() ")" "{" instrs() "}"
}

void instr2(): {}
{
    instru() | "(" listexp() ")"
}

void instru() : {}
{
    <ASSIGN_OPERATOR> exp()                              |
    <ADD_OPERATOR><ASSIGN_OPERATOR> exp() |
    <ADD_OPERATOR><ADD_OPERATOR>
}

void ELSE() : {}
{
    <ELSE> "{" instrs() "}" | empty()
}

void I() : {}
{
    ident() | <IDENTIFIER> 
}
void listexp() : {}
{
    exp() listexp2() | empty()

}

void listexp2() : {}
{
    <VIRGULE> listexp() |
    empty()
}