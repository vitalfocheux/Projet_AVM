options {
    STATIC = false;
}

PARSER_BEGIN(MiniJaja)
package fr.m1comp5.LexerParserGenerator.MiniJajaParser;
import java.io.FileReader;

public class MiniJaja
{
    public static MiniJaja getInstance(String filename)
    {
        FileReader reader = null;
        try
        {
            reader = new FileReader(filename);
        }
        catch (Exception e)
        {
            System.out.println(e.getMessage());
            return null;
        }
        return new MiniJaja(reader);
    }
}
PARSER_END(MiniJaja)

/* To skip */
SKIP :
{
    " "                                              |
    "\t"                                             |
    "\r"                                             |
    "\n"                                             |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>        |
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">

 }

/* MiniJaja reserved keywords */
<DEFAULT> TOKEN :
{
    <CLASS: "class">     |
    <MAIN: "main">       |
    <VOID: "void">       |
    <INT: "int">         |
    <BOOLEAN: "boolean"> |
    <FINAL: "final">     |
    <TRUE: "true">       |
    <FALSE: "false">     |
    <LENGTH: "length">   |
    <WHILE: "while">     |
    <RETURN: "return">   |
    <WRITE: "write">     |
    <WRITELN: "writeln"> |
    <IF : "if">          |
    <ELSE : "else">
}

/* MiniJaja operator */
<DEFAULT> TOKEN :
{
    <ADD: "+">                  |
    <SUB: "-">                  |
    <DIV: "/">                  |
    <MUL: "*">                  |
    <SUP: ">">                  |
    <INF: "<">                  |
    <AND: "&&">                 |
    <OR: "||">                  |
    <EQUAL: "==">               |
    <NOT: "!">                  |
    <INCREMENT : "++">          |
    <ASSIGN_INCREMENT : "+=">   |
    <ASSIGN: "=">
}

/* MiniJaja Separator */
<DEFAULT> TOKEN :
{
    <SEMICOLON: ";">    |
    <COMMA: "," >       |
    <LCBRACKET: "{">    |
    <RCBRACKET: "}">    |
    <LPAR: "(">         |
    <RPAR: ")">         |
    <LBRACKET: "[">     |
    <RBRACKET: "]">
}

<DEFAULT> TOKEN :
{
    <IDENTIFIER: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])*> |
    <NUMBER: (["0"-"9"])+>                                          |
    <STRING:  "\"" (~["\""])* "\"">
}

SimpleNode start() : {}
{
    classe() {return jjtThis;}
}

void classe() #classe : {}
{
    <CLASS> ident() <LCBRACKET> decls() methmain() <RCBRACKET>
}

private void ident() #ident : {}
{
    <IDENTIFIER>
}

private void decls() : {}
{
    decl() decls1() #decls(2) |
    empty() #vnil
}

private void decls1() : {}
{
    <SEMICOLON> decls()
}

private void decl() : {}
{
    typemeth() ident() decl1() |
    <FINAL> type() ident() vexp()
}

private void decl1() : {}
{
    <LPAR> entetes() <RPAR> <LCBRACKET> vars() instrs() <RCBRACKET> |
    var1()
}

private void vars() : {}
{
    var() <SEMICOLON> vars() |
    empty()

}

private void var() : {}
{
    typemeth() ident() var1() |
    <FINAL> type() ident() vexp()
}

private void var1() : {}
{
     <LBRACKET> exp() <RBRACKET> |
     vexp()
}

private void vexp() : {}
{
    <ASSIGN> exp() |
    empty()
}


private void methmain() : {}
{
    <MAIN> <LCBRACKET> vars() instrs() <RCBRACKET>
}

private void entetes() : {}
{
    entete() entetes1() |
    empty()
}

private void entetes1() : {}
{
    <COMMA> entetes() |
    empty()
}

private void entete() : {}
{
    type() ident()
}

private void instrs() : {}
{
    instr() instrs1() |
    empty()
}

private void instrs1() : {}
{
    <SEMICOLON> instrs()
}

private void instr() : {}
{
    ident() instr2()                           |
    <RETURN> exp()                             |
    <WRITE> <LPAR> instr3() <RPAR>                   |
    <WRITELN> <LPAR> instr3() <RPAR>                 |
    <IF> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET> ELSE() |
    <WHILE> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET>
}

private void instr1() : {}
{
    <ASSIGN> exp()                  |
    <ASSIGN_INCREMENT> exp()   |
    <INCREMENT>
}

private void instr2() : {}
{
    <LPAR> listexp() <RPAR> |
    ident2() instr1()
}

private void instr3() : {}
{
    ident() |
    <STRING>
}

private void ELSE() : {}
{
    <ELSE> <LCBRACKET> instrs() <RCBRACKET> |
    empty()
}

private void listexp() : {}
{
    exp() listexp1() |
    empty()
}

private void listexp1() : {}
{
    <COMMA> listexp() |
    empty()
}

private void exp() : {}
{
    <NOT> exp1()            |
    <SUB> exp1() exp3()     |
    exp1() exp3()
}

private void exp1() : {}
{
    exp2() exp4()
}

private void exp2() : {}
{
    terme() exp5()
}

private void exp3() : {}
{
    <AND> exp1() exp3() |
    <OR> exp1() exp3()  |
    empty()
}

private void exp4() : {}
{
    <EQUAL> exp2() exp4()   |
    <SUP> exp2() exp4()     |
    empty()
}

private void exp5() : {}
{
    <ADD> terme() exp5() |
    <SUB> terme() exp5() |
    empty()
}

private void terme() : {}
{
    fact() terme1()
}

private void terme1() : {}
{
    <MUL> fact() terme1() |
    <DIV> fact() terme1() |
    empty()
}

private void fact() : {}
{
    ident() fact1()                 |
    <LENGTH> <LPAR> ident() <RPAR>  |
    <TRUE>                          |
    <FALSE>                         |
    <NUMBER>                        |
    <LPAR> exp() <RPAR>
}

private void fact1() : {}
{
    <LPAR> listexp() <RPAR> |
    ident2()
}

private void ident1() : {}
{
    ident() ident2()
}

private void ident2() : {}
{
    <LBRACKET> exp() <RBRACKET> |
    empty()
}

private void typemeth() : {}
{
    <VOID> |
    type()
}

private void type() : {}
{
    <INT> |
    <BOOLEAN>
}

private void empty() : {}
{
    {}
}