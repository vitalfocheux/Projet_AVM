options {
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    MULTI = true;
    VISITOR = true;
}

PARSER_BEGIN(MiniJaja)
package fr.m1comp5.Analyzer.mjj.generated;

public class MiniJaja
{
}
PARSER_END(MiniJaja)

/* To skip */
SKIP :
{
    " "                                              |
    "\t"                                             |
    "\r"                                             |
    "\n"                                             |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>        |
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">

 }

/* MiniJaja reserved keywords */
<DEFAULT> TOKEN :
{
    <CLASS: "class">     |
    <MAIN: "main">       |
    <VOID: "void">       |
    <INT: "int">         |
    <BOOLEAN: "boolean"> |
    <FINAL: "final">     |
    <TRUE: "true">       |
    <FALSE: "false">     |
    <LENGTH: "length">   |
    <WHILE: "while">     |
    <RETURN: "return">   |
    <WRITE: "write">     |
    <WRITELN: "writeln"> |
    <IF : "if">          |
    <ELSE : "else">
}

/* MiniJaja operator */
<DEFAULT> TOKEN :
{
    <ADD: "+">                  |
    <SUB: "-">                  |
    <DIV: "/">                  |
    <MUL: "*">                  |
    <SUP: ">">                  |
    <INF: "<">                  |
    <AND: "&&">                 |
    <OR: "||">                  |
    <EQUAL: "==">               |
    <NOT: "!">                  |
    <INCREMENT : "++">          |
    <ASSIGN_INCREMENT : "+=">   |
    <ASSIGN: "=">
}

/* MiniJaja Separator */
<DEFAULT> TOKEN :
{
    <SEMICOLON: ";">    |
    <COMMA: "," >       |
    <LCBRACKET: "{">    |
    <RCBRACKET: "}">    |
    <LPAR: "(">         |
    <RPAR: ")">         |
    <LBRACKET: "[">     |
    <RBRACKET: "]">
}

<DEFAULT> TOKEN :
{
    <IDENTIFIER: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*> |
    <NUMBER: (["0"-"9"])+>                                          |
    <STRING:  "\"" (~["\""])* "\"">
}

public SimpleNode start() #Root : {}
{
    classe() {return jjtThis;}
}

private void classe() #Classe(3) : {}
{
    <CLASS> ident() <LCBRACKET> decls() methmain() <RCBRACKET>
}

private void ident() #Ident : {Token t;}
{
    t = <IDENTIFIER> {jjtThis.value = t.image;}
}

private void decls() : {}
{
    decl() decls1() |
    empty() #Vnil
}

private void decls1() : {}
{
    <SEMICOLON> decls() #Decls(2)
}

private void decl() : {}
{
    typemeth() ident() decl1()           |
    <FINAL> type() ident() vexp() #Cst(3)
}

private void decl1() : {}
{
    <LPAR> entetes() <RPAR> <LCBRACKET> vars() instrs() <RCBRACKET> #Methode(5) |
    var1()
}

private void vars() : {}
{
    var() vars1() |
    empty() #Vnil
}

private void vars1() : {}
{
    <SEMICOLON> vars() #Vars(2)
}

private void var() : {}
{
    typemeth() ident() var1()            |
    <FINAL> type() ident() vexp() #Cst(3)
}

private void var1() : {}
{
     <LBRACKET> exp() <RBRACKET> #Tableau(3) |
     vexp() #Var(3)
}

private void vexp() : {}
{
    <ASSIGN> exp() |
    empty() #Omega
}


private void methmain() #Main(2) : {}
{
    <MAIN> <LCBRACKET> vars() instrs() <RCBRACKET>
}

private void entetes() : {}
{
    entete() entetes1() |
    empty() #Enil
}

private void entetes1() : {}
{
    <COMMA> entetes() #Entetes(2) |
    empty() #Enil
}

private void entete() : {}
{
    type() ident() #Entete(2)
}

private void instrs() : {}
{
    instr() instrs1() |
    empty() #Inil
}

private void instrs1() : {}
{
    <SEMICOLON> instrs() #Instrs(2)
}

private void instr() : {}
{
    ident() instr2()                                                        |
    <RETURN> exp() #Retour                                                  |
    <WRITE> <LPAR> instr3() <RPAR> #Ecrire(1)                               |
    <WRITELN> <LPAR> instr3() <RPAR> #EcrireLn(1)                           |
    <IF> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET> ELSE() #Si(3) |
    <WHILE> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET> #TantQue(2)
}

private void instr1() : {}
{
    <ASSIGN> exp() #Affectation(2)     |
    <ASSIGN_INCREMENT> exp() #Somme(2) |
    <INCREMENT> #Increment(1)
}

private void instr2() : {}
{
    <LPAR> listexp() <RPAR> #AppelI(2) |
    [ident2()] instr1()
}

private void instr3() : {}
{
    ident() |
    chaine()
}

private void ELSE() : {}
{
    <ELSE> <LCBRACKET> instrs() <RCBRACKET> |
    empty() #Inil
}

private void listexp() : {}
{
    exp() listexp1() #ListExp(2) |
    empty() #Exnil
}

private void listexp1() : {}
{
    <COMMA> exp() listexp1() #ListExp(2) |
    empty() #Exnil
}

private void exp() : {}
{
    <NOT> exp1() #Not |
    exp1() exp3()
}

private void exp3() : {}
{
    (
        <AND> exp1() #Et(2) |
        <OR> exp1() #Ou(2)
    ) exp3() |
    {}
}

private void exp1() : {}
{
    exp2() exp4()
}

private void exp4() : {}
{
    (
        <EQUAL> exp2() #Eq(2) |
        <SUP> exp2() #Sup(2)
    ) exp4() |
    {}
}

private void exp2() : {}
{
    terme() exp5() |
    <SUB> terme() #Neg
}


private void exp5() : {}
{
    (
        <ADD> terme() #Add(2) |
        <SUB> terme() #Sub(2)
    ) exp5() |
    {}
}

private void terme() : {}
{
    fact() terme1()
}

private void terme1() : {}
{
    (
        <MUL> fact() #Mul(2) |
        <DIV> fact() #Div(2)
    ) terme1() |
    {}
}

private void fact() : {}
{
    ident() fact1()                          |
    <LENGTH> <LPAR> ident() <RPAR>  #Longeur(1) |
    <TRUE> #Vrai                             |
    <FALSE> #Faux                            |
    nbre()                                   |
    <LPAR> exp() <RPAR> #Exp(1)
}

private void fact1() : {}
{
    <LPAR> listexp() <RPAR> #AppelE(2) |
    [ident2()]
}

private void ident2() : {}
{
    <LBRACKET> exp() <RBRACKET> #Tab(2)
}

private void typemeth() : {}
{
    <VOID> #Rien |
    type()
}

private void type() : {}
{
    <INT> #Entier     |
    <BOOLEAN> #Booleen
}

private void empty() : {}
{
    {}
}

void nbre() #Nbre : {int x; Token t;} {
	t = <NUMBER> {
		try { x = Integer.parseInt(t.image);
		} catch (NumberFormatException ee) {
		   System.err.println(ee.getMessage());
		   x = 0;
		}
		jjtThis.jjtSetValue(x);
	}
}

void chaine() #Chaine : {Token t;}
{
  t = <STRING> {jjtThis.value = t.image;}
}