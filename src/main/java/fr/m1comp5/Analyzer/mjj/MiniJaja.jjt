options {
    STATIC = false;
    NODE_DEFAULT_VOID = true;
    MULTI = true;
    VISITOR = true;
}

PARSER_BEGIN(MiniJaja)
package fr.m1comp5.Analyzer.mjj.bin;

public class MiniJaja
{
}
PARSER_END(MiniJaja)

/* To skip */
SKIP :
{
    " "                                              |
    "\t"                                             |
    "\r"                                             |
    "\n"                                             |
    <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>        |
    <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">

 }

/* MiniJaja reserved keywords */
<DEFAULT> TOKEN :
{
    <CLASS: "class">     |
    <MAIN: "main">       |
    <VOID: "void">       |
    <INT: "int">         |
    <BOOLEAN: "boolean"> |
    <FINAL: "final">     |
    <TRUE: "true">       |
    <FALSE: "false">     |
    <LENGTH: "length">   |
    <WHILE: "while">     |
    <RETURN: "return">   |
    <WRITE: "write">     |
    <WRITELN: "writeln"> |
    <IF : "if">          |
    <ELSE : "else">
}

/* MiniJaja operator */
<DEFAULT> TOKEN :
{
    <ADD: "+">                  |
    <SUB: "-">                  |
    <DIV: "/">                  |
    <MUL: "*">                  |
    <SUP: ">">                  |
    <INF: "<">                  |
    <AND: "&&">                 |
    <OR: "||">                  |
    <EQUAL: "==">               |
    <NOT: "!">                  |
    <INCREMENT : "++">          |
    <ASSIGN_INCREMENT : "+=">   |
    <ASSIGN: "=">
}

/* MiniJaja Separator */
<DEFAULT> TOKEN :
{
    <SEMICOLON: ";">    |
    <COMMA: "," >       |
    <LCBRACKET: "{">    |
    <RCBRACKET: "}">    |
    <LPAR: "(">         |
    <RPAR: ")">         |
    <LBRACKET: "[">     |
    <RBRACKET: "]">
}

<DEFAULT> TOKEN :
{
    <IDENTIFIER: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*> |
    <NUMBER: (["0"-"9"])+>                                          |
    <STRING:  "\"" (~["\""])* "\"">
}

SimpleNode start() #root : {}
{
    classe() {return jjtThis;}
}

private void classe() #classe(3) : {}
{
    <CLASS> ident() <LCBRACKET> decls() methmain() <RCBRACKET>
}

private void ident() #ident : {Token t;}
{
    t = <IDENTIFIER> {jjtThis.value = t.image;}
}

private void decls() : {}
{
    decl() decls1() |
    empty() #vnil
}

private void decls1() : {}
{
    <SEMICOLON> decls() #decls(2)
}

private void decl() : {}
{
    typemeth() ident() decl1()           |
    <FINAL> type() ident() vexp() #cst(3)
}

private void decl1() : {}
{
    <LPAR> entetes() <RPAR> <LCBRACKET> vars() instrs() <RCBRACKET> #methode(5) |
    var1()
}

private void vars() : {}
{
    var() <SEMICOLON> vars() #vars(2) |
    empty() #vnil

}

private void var() : {}
{
    typemeth() ident() var1()            |
    <FINAL> type() ident() vexp() #cst(3)
}

private void var1() : {}
{
     <LBRACKET> exp() <RBRACKET> #tableau(3) |
     vexp() #var(3)
}

private void vexp() : {}
{
    <ASSIGN> exp() |
    empty() #omega
}


private void methmain() #main(2) : {}
{
    <MAIN> <LCBRACKET> vars() instrs() <RCBRACKET>
}

private void entetes() : {}
{
    entete() entetes1() |
    empty() #enil
}

private void entetes1() : {}
{
    <COMMA> entetes() #entetes(2) |
    empty() #enil
}

private void entete() : {}
{
    type() ident() #entete(2)
}

private void instrs() : {}
{
    instr() instrs1() |
    empty() #inil
}

private void instrs1() : {}
{
    <SEMICOLON> instrs() #instrs(2)
}

private void instr() : {}
{
    ident() instr2()                                           |
    <RETURN> exp() #retour                                     |
    <WRITE> <LPAR> instr3() <RPAR> #ecrire(1)                  |
    <WRITELN> <LPAR> instr3() <RPAR> #ecrireln(1)              |
    <IF> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET> ELSE() #si(3) |
    <WHILE> <LPAR> exp() <RPAR> <LCBRACKET> instrs() <RCBRACKET> #tantque(2)
}

private void instr1() : {}
{
    <ASSIGN> exp() #affectation(2)     |
    <ASSIGN_INCREMENT> exp() #somme(2) |
    <INCREMENT> #increment(1)
}

private void instr2() : {}
{
    <LPAR> listexp() <RPAR> #appelI(2) |
    [ident2()] instr1()
}

private void instr3() : {}
{
    ident() |
    chaine()
}

private void ELSE() : {}
{
    <ELSE> <LCBRACKET> instrs() <RCBRACKET> |
    empty() #inil
}

private void listexp() : {}
{
    exp() listexp1() #listexp(2) |
    empty() #exnil
}

private void listexp1() : {}
{
    <COMMA> exp() listexp1() #listexp(2) |
    empty() #exnil
}

private void exp() : {}
{
    <NOT> exp1() exp3() #not(1) |
    exp1() exp3()
}

private void exp1() : {}
{
    exp2() exp4()
}

private void exp2() : {}
{
    terme() exp5() |
    <SUB> terme() exp5() #neg(1)
}

private void exp3() : {}
{
    <AND> exp1() exp3() #et(2) |
    <OR> exp1() exp3() #ou(2)  |
    empty()
}

private void exp4() : {}
{
    <EQUAL> exp2() exp4() #eq(2) |
    <SUP> exp2() exp4() #sup(2)  |
    empty()
}

private void exp5() : {}
{
    <ADD> terme() exp5() #add(2) |
    <SUB> terme() exp5() #sub(2) |
    empty()
}

private void terme() : {}
{
    fact() terme1()
}

private void terme1() : {}
{
    <MUL> fact() terme1() #mul(2) |
    <DIV> fact() terme1() #div(2) |
    empty()
}

private void fact() : {}
{
    ident() fact1()                 |
    <LENGTH> <LPAR> ident() <RPAR>  #longeur(1) |
    <TRUE> #vrai                      |
    <FALSE> #faux                     |
    nbre()                            |
    <LPAR> exp() <RPAR> #exp(1)
}

private void fact1() : {}
{
    <LPAR> listexp() <RPAR> #appelE(2) |
    [ident2()]
}

private void ident2() : {}
{
    <LBRACKET> exp() <RBRACKET> #tab(2)
}

private void typemeth() : {}
{
    <VOID> #rien |
    type()
}

private void type() : {}
{
    <INT> #entier     |
    <BOOLEAN> #booleen
}

private void empty() : {}
{
    {}
}

void nbre() #nbre : {int x;} {
	<NUMBER> {
		try { x = Integer.parseInt(token.image);
		} catch (NumberFormatException ee) {
		   System.err.println("Error: " + token.image + " is not a number.");
		   x = 0;
		}
		jjtThis.jjtSetValue(x);
	}
}

void chaine() #chaine : {Token t;}
{
  t = <STRING> {jjtThis.value = t.image;}
}